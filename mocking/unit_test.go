package mocking

import (
	"encoding/base64"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// First test implementation - not using any mock
func TestUnit_SomeFunc_1(t *testing.T) {
	// arrange

	// ut - is short for unit under test
	// for the sake of brevity, the unit is already setup for dependency injection.
	ut := unit{
		dep:     NewExternalDependency(),
		encoder: base64.StdEncoding,
	}

	// act
	result, err := ut.SomeFunc("bla")

	// assert
	is := assert.New(t)
	is.Nil(err)

	// 'bW9vOiBibGE=' value, produced by the base64 encoding, of 'moo: bla' which is the result of the ExternalDependency
	// The test is thus coupled to the underlying implementation of the dependencies, hindering reusability of the unit.
	is.Equal("bW9vOiBibGE=", result)
}

// Second test, introducing a roll our own mock to replace ExternalDependency implementation
func TestUnit_SomeFunc_2(t *testing.T) {
	// arrange
	dep := &mockExternalDep1{}

	ut := unit{
		dep:     dep,
		encoder: base64.StdEncoding,
	}

	// act
	result, err := ut.SomeFunc("foo")

	// assert
	is := assert.New(t)
	is.Nil(err)

	// Again, we're testing against the expected result of the base64 encoding. In this case, the value depends on
	// what has been hard coded in the mock.
	is.Equal("YmFy", result)
}

// Third test, using our roll our own mocked ExternalDependency - to test an error case generated by invalid input.
// Testing the error requires modifying our mock to simulate an invalid input and return an error. This aims to
// illustrate that the provided approach requires hard coding in our mock implementation all the required input/output
// for all of our test cases, increasing rigidity (resistance to changes) of our test suite.
func TestUnit_SomeFunc_3(t *testing.T) {
	// arrange
	dep := &mockExternalDep1{}

	ut := unit{
		dep:     dep,
		encoder: base64.StdEncoding,
	}

	// act
	result, err := ut.SomeFunc("invalid")

	// assert
	is := assert.New(t)
	is.NotNil(err)
	is.Equal("invalid", result)
}

// Fourth test. Replacing our mock object by one implemented with github.com/stretchr/testify/mock and also using
// a mock for the external encoder. Note that we created an interface to abstract the Base64.Encoding object with
// only the method that we are using from it. Since interfaces in golang are implicit (if an object exposes
// the same method signatures as the interface's, then it can be used as this interface), then dependencies from
// external package can be abstracted even if no interface is provided for them. Also, it allows you to write mock
// implementations only for the method you are using!
//
// Observe benefits of configuring the test cases expectation in the test + observability
func TestUnit_SomeFunc_4(t *testing.T) {
	// arrange
	dep := &mockExternalDep2{}
	dep.
		On("DoSomething", "bla").
		Return("abcd", nil).
		Once()

	encoder := mockEncoder{}
	encoder.
		On("EncodeToString", []byte("abcd")).
		Return("babayaga").
		Once()

	ut := unit{
		dep:     dep,
		encoder: encoder,
	}

	// act
	result, err := ut.SomeFunc("bla")

	// assert
	is := assert.New(t)

	// this validates that our mock objects have been called with the expected values and methods, providing observability
	// that was lacking in our roll our own model.
	dep.AssertExpectations(t)
	encoder.AssertExpectations(t)

	is.Nil(err)
	// yay! we are not coupled to dependencies implementation to validate our logic.
	// you may point out that we are not validating the correct behaviour of our dependencies anymore, and you would
	// be right! it depends what types of test you are writing, but in the context of unit tests, testing only the
	// unit in scope allows for simpler and more maintainable tests, faster feedback loops and also more reusable
	// units!
	is.Equal("babayaga", result)
}

// Fifth test - the error case revisited. No change required to the mock implementation to support this new use cases;
// input and output expectations are configured directly in the test case, with no conflict with the other test case
// (note that the same input value of 'bla' is used for both).
func TestUnit_SomeFunc_5(t *testing.T) {
	// arrange
	dep := &mockExternalDep2{}
	dep.
		On("DoSomething", "bla").
		Return("", fmt.Errorf("i am an error")).
		Once()

	encoder := &mockEncoder{}

	ut := unit{
		dep:     dep,
		encoder: encoder,
	}

	// act
	result, err := ut.SomeFunc("bla")

	// assert
	is := assert.New(t)

	dep.AssertExpectations(t)

	// validating explicitly that the method has not been called, because of the previous error
	encoder.AssertNotCalled(t, "EncodeToString")

	is.NotNil(err)
	is.Equal("", result)
}
